## (4,4): Numbers

### Or: In the Desert
### Or: The Book of War
### Or: The Great Complaining

---

```
This file begins the long battle
in which our heroes will break
down and rebuild the First Code
as a gift to Our People of that
which is their eternal birthright.
```

---

0: Quit your bitching.

1: I wasn't bit---

0: Doesn't matter. Time for war.

---


![[godel-1931-paper-05.jpg]]

Todo: Split into 2 pictures.

```python
def Div(x, y):
    """ 1. x is divisible by y. """
    z = 0
    while z <= x:
        if x == y*z:
            return True
        z += 1
    return False

assert Div(8, 2) == True
assert Div(7, 2) == False
assert Div(5**3, 5**2) == True
assert Div(5**2, 5**3) == False
```

```python
def Prim(x):
    """ 2. x is a prime number. """
    if not (x > 1):
        return False
    z = 0
    while z <= x:
        if z != 1 and z != x and Div(x, z):
            return False
        z += 1
    return True

assert Prim(1) == False
assert Prim(2) == True
assert Prim(3) == True
assert Prim(4) == False
assert Prim(5) == True
assert Prim(7) == True
assert Prim(9) == False
```

![[godel-1931-paper-06.jpg]]

```python
def nPrx(n, x):
    """ 3. nPrx is the nth (in order of magnitude) prime number contained in x. """
    if n == 0:
        return 0
    prev = nPrx(n-1, x)
    pred = lambda y: Prim(y) and Div(x, y) and y > prev
    return Eps(x, pred)

assert nPrx(0, 2*(3**2)*7*11) == 0
assert nPrx(1, 2*(3**2)*7*11) == 2
assert nPrx(2, 2*(3**2)*7*11) == 3
assert nPrx(3, 2*(3**2)*7*11) == 7
assert nPrx(4, 2*(3**2)*7*11) == 11
```


![[godel-1931-paper-07.jpg]]

```python
def Fac(n):
    """ 4. Factorial. """
    if n == 0:
        return 1
    return n*Fac(n-1)

assert Fac(0) == 1
assert Fac(1) == 1
assert Fac(2) == 2
assert Fac(3) == 6
assert Fac(4) == 24
```

![[godel-1931-paper-08.jpg]]

```python
def Pr(n):
    """ 5. Pr(n) is the n-th prime number (in order of magnitude). """
    if n == 0:
        return 0
    return Eps(max=Fac(Pr(n-1)) + 1, pred=lambda y: Prim(y) and y > Pr(n-1))

assert Pr(1) == 2
assert Pr(2) == 3
assert Pr(3) == 5
assert Pr(4) == 7
assert Pr(5) == 11
assert Pr(6) == 13
```

![[godel-1931-paper-09.jpg]]

```python
def nGlx(n, x):
    """ 6. nGlx is the nth term of the series of numbers assigned to x. """
    pred = lambda y: Div(x, nPrx(n, x)**y) and not Div(x, nPrx(n, x)**(y+1))
    return Eps(x, pred)

# x = (2**3) * (3**2) * (5**1) encodes the list [3, 2, 1]
x = x = (2**3) * (3**2) * (5**1) 
assert nGlx(1, x) == 3
assert nGlx(2, x) == 2
assert nGlx(3, x) == 1
assert nGlx(4, x) == 0
```

![[godel-1931-paper-10.jpg]]

```python
```python
def l(x):
    """ 7. l(x) is the length of the series of numbers assigned to x. """
    pred = lambda y: (nPrx(y, x) > 0) and (nPrx(y+1, x) == 0)
    return Eps(x, pred)

assert l(2*3*5) == 3        # the length of [1, 1, 1] is 3    
assert l(1) == 0            # 1 encodes the empty series
assert l(2**5) == 1         # 2**5 is the singleton list [5]
```


![[godel-1931-paper-11.jpg]]

```python
def join(x, y):
    """ 8. join(x, y) corresponds to "joining together" two finite series of numbers. """
    lx = l(x)
    ly = l(y)
    max = Pr(lx + ly)**(x+y)

    def pred1(z):
        return all(nGlx(n, z) == nGlx(n, x) for n in range(lx + 1))

    def pred2(z):
        return all(nGlx(n + lx, z) == nGlx(n, y) for n in range(1, ly + 1))

    def pred(z):
        return pred1(z) and pred2(z)

    return Eps(max, pred)

a = 2                       # [1]
b = 2*3                     # [1,1]
c = 2*3*5                   # [1,1,1]
assert join(a, b) == c

a = 2*3                     # [1,1]
b = 5                       # [1]
c = 2*3*5                   # [1,1,1]
assert join(a, b) == c

a = (2**3)*(3**2)           # [3,2]
b = (2**1)                  # [1]
c = (2**3)*(3**2)*(5**1)    # [3,2,1]
assert join(a, b) == c

a = (2**3)                  # [3]
b = (2**2)*(3**1)           # [2,1]
c = (2**3)*(3**2)*(5**1)    # [3,2,1]
assert join(a, b) == c
```

![[godel-1931-paper-12.jpg]]

```python
def R(x):
    """ 9. R(x) corresponds to the number-series consisting
           only of the number x (for x > 0). """
    return 2**x

a = R(2)                    # a = [2]
b = R(3)                    # b = [3]
c = join(a, b)              # c = join(a,b)
assert l(c) == 2            # len(c) == 2
assert nGlx(1, c) == 2      # c[1] == 2
assert nGlx(2, c) == 3      # c[2] == 3
```

![[godel-1931-paper-13.jpg]]

```python
def E(x):
    """ 10. E(x) corresponds to the operation of 'bracketing'. """
    lp = godel['(']         # written 11, in Gödel's paper
    rp = godel[')']         # written 13, in Gödel's paper
    R11  = R(lp)            # compute the left-most term
    R13  = R(rp)            # compute the right-most term
    R11x = join(R11, x)     # compute the join "R(11) * x"
    return join(R11x, R13)  # compute "(R(11) * x) * R(13)"

# Now, the simplest test of above function might
# be something like this:
#
# a = R(2)                      # a = [2]
# Ea = E(a)                     # Ea = '(' + str(a) + ')', conceptually
# assert l(E(a)) == l(a) + 2    # the extra 2 comes from the '(' and ')'
#
# If we run that test, however, we find that it hangs.
#
# Let's step through the code.
```

```python
>>> a = R(2)
>>> a
4

>>> # E(4) == ?
>>> # The function hangs if we call it,
>>> # so let's step through it manually.

>>> lp = godel['(']         # written 11, in Gödel's paper
>>> rp = godel[')']         # written 13, in Gödel's paper

>>> lp
11

>>> rp
13

>>> R11 = R(lp)             # compute the left-most term
>>> R13 = R(rp)             # compute the right-most term

>>> R11
2048

>>> R13
8192

>>> R11x = join(R11, x)     # this is where the function hangs
```

1: So, what now?

0: I dunno.

1: Did we make a mistake?

0: I don't think so. This is exactly the definitions from Gödel's paper.

1: So why's it hanging?

0: What do you think?

1: Maybe we need to add a cache.

0: How so?

1: I mean, every time we compute anything we're sort of recomputing everything. Once we compute anything we should be able to remember it for later. It's just computing whole numbers from whole numbers after all.

0: Great point! How would you do that?

1: Probably the easiest way I can think of.

0: Show me.

---

_(Narrator: A bit later, 0 and 1 return, having written the following function.)_

---

```python
def and_godel_said(f):

    """
        Not in Gödel's paper.

        We'll use this function to remember the results
        of computations we've done already, because
        otherwise things start to seriously slow down
        by somewhere around equation 10. 
    """

    memory = {}

    def f_with_memory(*args):

        if args in memory:
            return memory[args]

        result = f(*args)

        memory[args] = result

        return result

    # read some attributes from the original function f,
    # like its name and docstring, and slap those onto
    # the function f_with_memory so its more convincing
    # in its attempt to look like f, even though it's not.
    attrs_to_steal = ('__name__', '__doc__')

    for attr in attrs_to_steal:
        setattr(f_with_memory, attr, getattr(f, attr))

    return f_with_memory
```

---

_(Narrator: And they added `@and_godel_said` above each function, so the code now looks like this.)_


---

1: Ok so, running everything up to but not including Godel's 10th function: $E(x)$, we get the following.

```sh
$ time ./godel-nocache

real	0m15.877s
user	0m15.836s
sys	0m0.011s
```

1: And running the same thing with the simple caching decorator above, we get this:

```sh
$ time ./godel

real	0m0.127s
user	0m0.119s
sys	0m0.007s

```

1: So it's faster now by a factor of 125!

0: Sorry I was thinking something else. You got a 125% speed-up?

1: No dummy, a 125x speed-up!

0: Amazing!

1: What now?

0: Does $E(x)$ work now?


---

![[godel-1931-paper-14.jpg]]

```python

```

![[godel-1931-paper-15.jpg]]

```python

```

![[godel-1931-paper-16.jpg]]

```python

```

![[godel-1931-paper-17.jpg]]

```python

```

![[godel-1931-paper-18.jpg]]


![[godel-1931-paper-19.jpg]]


![[godel-1931-paper-20.jpg]]


![[godel-1931-paper-21.jpg]]


![[godel-1931-paper-22.jpg]]


![[godel-1931-paper-23.jpg]]


![[godel-1931-paper-24.jpg]]


![[godel-1931-paper-25.jpg]]


![[godel-1931-paper-26.jpg]]


![[godel-1931-paper-27.jpg]]


![[godel-1931-paper-28.jpg]]


![[godel-1931-paper-29.jpg]]


![[godel-1931-paper-30.jpg]]


![[godel-1931-paper-31.jpg]]


![[godel-1931-paper-32.jpg]]


![[godel-1931-paper-33.jpg]]


![[godel-1931-paper-34.jpg]]


![[godel-1931-paper-35.jpg]]


![[godel-1931-paper-36.jpg]]


![[godel-1931-paper-37.jpg]]


![[godel-1931-paper-38.jpg]]


![[godel-1931-paper-39.jpg]]


![[godel-1931-paper-40.jpg]]


![[godel-1931-paper-41.jpg]]


![[godel-1931-paper-42.jpg]]


![[godel-1931-paper-43.jpg]]


![[godel-1931-paper-44.jpg]]


![[godel-1931-paper-45.jpg]]


![[godel-1931-paper-46.jpg]]


![[godel-1931-paper-47.jpg]]


![[godel-1931-paper-48.jpg]]


![[godel-1931-paper-49.jpg]]


![[godel-1931-paper-50.jpg]]


![[godel-1931-paper-51.jpg]]

<<<<<<< HEAD
goto: [[lost+found/4/4]]
=======
goto: [[lost+found/4/5]]
>>>>>>> 7c3b5fb (Begin The Great Refactor of Lost and Found!)
