## (4,4): Numbers

### Or: In the Desert
### Or: The Book of War
### Or: The Great Complaining

---

```
This file begins the long battle
in which our heroes will break
down and rebuild the First Code
as a gift to Our People of that
which is their eternal birthright.
```

---

0: Quit your bitching.

1: I wasn't bit---

0: Doesn't matter. Time for war.

---

![[godel-1931-paper-05-1.jpg]]

```python
def Div(x, y):
    """ 1. x is divisible by y. """
    z = 0
    while z <= x:
        if x == y*z:
            return True
        z += 1
    return False

assert Div(8, 2) == True
assert Div(7, 2) == False
assert Div(5**3, 5**2) == True
assert Div(5**2, 5**3) == False
```

![[godel-1931-paper-05-2.jpg]]

```python
def Prim(x):
    """ 2. x is a prime number. """
    if not (x > 1):
        return False
    z = 0
    while z <= x:
        if z != 1 and z != x and Div(x, z):
            return False
        z += 1
    return True

assert Prim(1) == False
assert Prim(2) == True
assert Prim(3) == True
assert Prim(4) == False
assert Prim(5) == True
assert Prim(7) == True
assert Prim(9) == False
```

![[godel-1931-paper-06.jpg]]

```python
def nPrx(n, x):
    """ 3. nPrx is the nth (in order of magnitude) prime number contained in x. """
    if n == 0:
        return 0
    prev = nPrx(n-1, x)
    pred = lambda y: Prim(y) and Div(x, y) and y > prev
    return Eps(x, pred)

assert nPrx(0, 2*(3**2)*7*11) == 0
assert nPrx(1, 2*(3**2)*7*11) == 2
assert nPrx(2, 2*(3**2)*7*11) == 3
assert nPrx(3, 2*(3**2)*7*11) == 7
assert nPrx(4, 2*(3**2)*7*11) == 11
```


![[godel-1931-paper-07.jpg]]

```python
def Fac(n):
    """ 4. Factorial. """
    if n == 0:
        return 1
    return n*Fac(n-1)

assert Fac(0) == 1
assert Fac(1) == 1
assert Fac(2) == 2
assert Fac(3) == 6
assert Fac(4) == 24
```

![[godel-1931-paper-08.jpg]]

```python
def Pr(n):
    """ 5. Pr(n) is the n-th prime number (in order of magnitude). """
    if n == 0:
        return 0
    return Eps(max=Fac(Pr(n-1)) + 1, pred=lambda y: Prim(y) and y > Pr(n-1))

assert Pr(1) == 2
assert Pr(2) == 3
assert Pr(3) == 5
assert Pr(4) == 7
assert Pr(5) == 11
assert Pr(6) == 13
```

![[godel-1931-paper-09.jpg]]

```python
def nGlx(n, x):
    """ 6. nGlx is the nth term of the series of numbers assigned to x. """
    pred = lambda y: Div(x, nPrx(n, x)**y) and not Div(x, nPrx(n, x)**(y+1))
    return Eps(x, pred)

# x = (2**3) * (3**2) * (5**1) encodes the list [3, 2, 1]
x = x = (2**3) * (3**2) * (5**1) 
assert nGlx(1, x) == 3
assert nGlx(2, x) == 2
assert nGlx(3, x) == 1
assert nGlx(4, x) == 0
```

![[godel-1931-paper-10.jpg]]

```python
```python
def l(x):
    """ 7. l(x) is the length of the series of numbers assigned to x. """
    pred = lambda y: (nPrx(y, x) > 0) and (nPrx(y+1, x) == 0)
    return Eps(x, pred)

assert l(2*3*5) == 3        # the length of [1, 1, 1] is 3    
assert l(1) == 0            # 1 encodes the empty series
assert l(2**5) == 1         # 2**5 is the singleton list [5]
```


![[godel-1931-paper-11.jpg]]

```python
def join(x, y):
    """ 8. join(x, y) corresponds to "joining together" two finite series of numbers. """
    lx = l(x)
    ly = l(y)
    max = Pr(lx + ly)**(x+y)

    def pred1(z):
        return all(nGlx(n, z) == nGlx(n, x) for n in range(lx + 1))

    def pred2(z):
        return all(nGlx(n + lx, z) == nGlx(n, y) for n in range(1, ly + 1))

    def pred(z):
        return pred1(z) and pred2(z)

    return Eps(max, pred)

a = 2                       # [1]
b = 2*3                     # [1,1]
c = 2*3*5                   # [1,1,1]
assert join(a, b) == c

a = 2*3                     # [1,1]
b = 5                       # [1]
c = 2*3*5                   # [1,1,1]
assert join(a, b) == c

a = (2**3)*(3**2)           # [3,2]
b = (2**1)                  # [1]
c = (2**3)*(3**2)*(5**1)    # [3,2,1]
assert join(a, b) == c

a = (2**3)                  # [3]
b = (2**2)*(3**1)           # [2,1]
c = (2**3)*(3**2)*(5**1)    # [3,2,1]
assert join(a, b) == c
```

![[godel-1931-paper-12.jpg]]

```python
def R(x):
    """ 9. R(x) corresponds to the number-series consisting
           only of the number x (for x > 0). """
    return 2**x

a = R(2)                    # a = [2]
b = R(3)                    # b = [3]
c = join(a, b)              # c = join(a,b)
assert l(c) == 2            # len(c) == 2
assert nGlx(1, c) == 2      # c[1] == 2
assert nGlx(2, c) == 3      # c[2] == 3
```

![[godel-1931-paper-13.jpg]]

```python
def E(x):
    """ 10. E(x) corresponds to the operation of 'bracketing'. """
    lp = godel['(']         # written 11, in Gödel's paper
    rp = godel[')']         # written 13, in Gödel's paper
    R11  = R(lp)            # compute the left-most term
    R13  = R(rp)            # compute the right-most term
    R11x = join(R11, x)     # compute the join "R(11) * x"
    return join(R11x, R13)  # compute "(R(11) * x) * R(13)"
```

0: Now, the simplest test of above function might be something like this:

```python
>>> a = R(2)          # a = [2]
>>> a
4

>>> # E(4) == ?
>>> # The function hangs if we call it,
>>> # so let's step through it manually.

>>> lp = godel['(']   # written 11, in Gödel's paper
>>> rp = godel[')']   # written 13, in Gödel's paper

>>> lp
11

>>> rp
13

# compute the left-most term
>>> R11 = R(lp)

# compute the right-most term
>>> R13 = R(rp)

>>> R11
2048

>>> R13
8192

# this is where the function hangs
>>> R11x = join(R11, x)
```

1: So, what now?

0: I dunno.

1: Did we make a mistake?

0: I don't think so. This is exactly the definitions from Gödel's paper.

1: So why's it hanging?

0: What do you think?

1: Maybe we need to add a cache.

0: How so?

1: I mean, every time we compute anything we're sort of recomputing everything. Once we compute anything we should be able to remember it for later. It's just computing whole numbers from whole numbers after all.

0: Great point! How would you do that?

1: Probably the easiest way I can think of.

0: Show me.

---

_(Narrator: A bit later, 0 and 1 return, having written the following function.)_

---

```python
def and_godel_said(f):

    """
        Not in Gödel's paper.

        We'll use this function to remember the results
        of computations we've done already, because
        otherwise things start to seriously slow down
        by somewhere around equation 10. 
    """

    memory = {}

    def f_with_memory(*args):

        if args in memory:
            return memory[args]

        result = f(*args)

        memory[args] = result

        return result

    return f_with_memory
```

---

_(Narrator: And they added `@and_godel_said` above each function.)_

---

1: Ok so, running everything up to but not including Godel's 10th function: $E(x)$, we get the following.

```sh
$ time ./godel-nocache

real	0m15.877s
user	0m15.836s
sys	0m0.011s
```

1: And running the same thing with the simple caching decorator above, we get this:

```sh
$ time ./godel

real	0m0.127s
user	0m0.119s
sys	0m0.007s

```

1: So it's faster now by a factor of 125!

0: Sorry I was thinking something else. You got a 125% speed-up?

1: No dummy, a 125x speed-up!

0: Amazing!

1: What now?

0: Does $E(x)$ work now?

1: Nope, still hanging.

0: Let's add some `print` statements.

1: Good idea.

_(Narrator: 1 adds 1 small print statement inside the Eps function, so now it looks like this.)_

```python
def Eps(max, pred):
    """ Gödel's name for what eventually becomes the μ operator. """
    y = 0
    while y <= max:
        print(f"Eps({max}, {pred}) at y = {y}")
        if pred(y):
            return y
        y += 1
    else:
        return 0
```

0: Great! Let's try $E(2)$ again.

1:

```python
>>> E(2)
```

_(Narrator: The characters see some very slow print statements that look like this.)_

```
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1772
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1773
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1774
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1775
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1776
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1777
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1778
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1779
Eps(2048, <function and_godel_said.<locals>.f_with_memory at 0x7f850968dbc0>) at y = 1780
```

_(Narrator: Once the variable `y` reaches 2048, the prints speed up, and they see this.)_

```python
Eps(3145, <function and_godel_said.<locals>.f_with_memory at 0x7f8534cfac00>) at y = 4
Eps(3145, <function and_godel_said.<locals>.f_with_memory at 0x7f8534cfac00>) at y = 5
Eps(3145, <function nGlx.<locals>.<lambda> at 0x7f8534cfa480>) at y = 1
Eps(1254793254356131123218617591703141365093456089025983680837860558548829234406593946811365022284164650932244868923121220062606422100022852380538230979131136144904068614262561960240557297533420522278153739037771529946217592341106898903181045752268502062718277395150240502814522346350862182245607613323205169715726265984357678912463663268799753615925901938180909772664259181890228350472826735573271087239814127192369934771422625348103974001254491483727601055187367397137996533729179714861455777059949383873788893395130822944099315055784766351017116236487512758087676108592914999593590438904404608324963657136209333918709431693260048118476465924630884619753370060347354572355603292299233595246572140013414935253540614062289976179755316780942047049893599912023952932081860807658979719553593760811362551798532760814868371950829505929313143082879644124621504867920299624372550718884716712141351592342578793983267555399307641154737459761361766391202256528847471610468965392120084888330249, <function and_godel_said.<locals>.f_with_memory at 0x7f8534cfb600>) at y = 3146
Eps(3146, <function nGlx.<locals>.<lambda> at 0x7f8534cfa480>) at y = 0
Eps(3146, <function nGlx.<locals>.<lambda> at 0x7f8534cfa480>) at y = 0
Eps(3146, <function and_godel_said.<locals>.f_with_memory at 0x7f8534cfb4c0>) at y = 0
Eps(3146, <function and_godel_said.<locals>.f_with_memory at 0x7f8534cfb4c0>) at y = 1
Eps(3146, <function and_godel_said.<locals>.f_with_memory at 0x7f8534cfb4c0>) at y = 2
```

1: Why are the first arguments to `Eps` increasing?

0: Remember we've got several things implemented in terms of `Eps`. I'd say we need to figure out the name of that function.

1: Which function?

0: `<function and_godel_said.<locals>.f_with_memory at 0x7f8534cfb4c0`

1: Got it. Why don't we have the name of that function?

0: Well `and_godel_said` is a function that takes a function and returns a function.

1: Very Church.

0: Very. But the thing it returns doesn't preserve the name of the original function.

1: Why does that matter?

0: Well it's the reason we're seeing that confusing `<function blah blah...>` thing instead of the actual function the code is stuck in.

1: Ah of course. How do we fix that?

0: Just whack the function name onto the function in the function.

1: This Godel code is surprisingly Alonzo.

0: Trinities work in mysterious ways.

_(Narrator: Our two characters modify the `and_godel_said` decorator, while Narrator describes it.)_

1: Ok got it.

_(Narrator: The function `and_godel_said` has been modified by the following diff:_

```python
--- vor	20XY-04-28 19:06:00 +0100
+++ nac	20XY-04-28 19:06:0ε +0100
@@ -22,5 +22,14 @@
 
         return result
 
+    # read some attributes from the original function f,
+    # like its name and docstring, and slap those onto
+    # the function f_with_memory so its more convincing
+    # in its attempt to look like f, even though it's not.
+    attrs_to_steal = ('__name__', '__qualname__', '__doc__')
+
+    for attr in attrs_to_steal:
+        setattr(f_with_memory, attr, getattr(f, attr))
+
     return f_with_memory
```

_)_[^1]

0: Great! Run it again.

_(Narrator: It hangs again.)_

1: G\*d dammit!

0: No no this is good.

1: How is this good? We're stuck on definition 10. We're supposed to get to FORTY SIX!

0: We're _supposed_ to get stuck on definition 10. It's perfect.

1: How's that perfect?

0: It's our names. Godel[^2] wanted us to see this.

1: _(Rolls eyes and looks at traceback.)_ Hey look!

0: At what?

1: The traceback. Look:

```python
KeyboardInterrupt                         Traceback (most recent call last)
Cell In[6], line 1
----> 1 E(2)

Cell In[5], line 28, in and_godel_said.<locals>.f_with_memory(*args)
     25 if args in memory:
     26     return memory[args]
---> 28 result = f(*args)
     30 memory[args] = result
     32 return result

Cell In[5], line 320, in E(x)
    318 R11  = R(lp)            # compute the left-most term
    319 R13  = R(rp)            # compute the right-most term
--> 320 R11x = join(R11, x)     # compute the join "R(11) * x"
    321 return join(R11x, R13)

Cell In[5], line 28, in and_godel_said.<locals>.f_with_memory(*args)
     25 if args in memory:
     26     return memory[args]
---> 28 result = f(*args)
     30 memory[args] = result
     32 return result

Cell In[5], line 258, in join(x, y)
    254 max = Pr(l(x) + l(y))**(x+y)
    256 join_predicate = make_join_predicate(x, y)
--> 258 return Eps(max, join_predicate)
```

1: We need to figure out where we're spending all our time.

0: Simple enough.

_(Narrator: 0 modifies the cache function so it now looks like this.)_

```python
CALLS = {}

def and_godel_said(f):

    """
        Not in Gödel's paper.

        We'll use this function to remember the results
        of computations we've done already, because
        otherwise things start to seriously slow down
        by somewhere around equation 10. 
    """

    memory = {}

    def f_with_memory(*args):

        if args in memory:
            return memory[args]

        argv = ', '.join(map(str, args))
        print(f"{f.__name__}({argv})")

        import time
        before = time.time()
        result = f(*args)
        after = time.time()

        CALLS.setdefault(f.__name__, []).append(after-before)

        memory[args] = result

        return result

    # read some attributes from the original function f,
    # like its name and docstring, and slap those onto
    # the function f_with_memory so its more convincing
    # in its attempt to look like f, even though it's not.
    attrs_to_steal = ('__name__', '__qualname__', '__doc__')

    for attr in attrs_to_steal:
        setattr(f_with_memory, attr, getattr(f, attr))

    return f_with_memory
```

1: What's that weird line?

0: Which one?

1: The one that says:

```python
CALLS.setdefault(f.__name__, []).append(after-before)
```

0: Easier to show than explain. It's just this:

```python
>>> d = {}

>>> d.setdefault('cake', 4)
4

>>> d
{'cake': 4}

>>> d.setdefault('cake', 5)
4

>>> d
{'cake': 4}

>>> d.setdefault('pie', 5)
5

>>> d
{'cake': 4, 'pie': 5}
```

1: Oh ok.[^3]

0: Now just add this at the bottom.

```python
try:
    a = E(2)
except KeyboardInterrupt:
    for k, l in CALLS.items():
        print(f"{k}: total calls = {len(l)}, total time = {sum(l)})")
```

0: Then run it until we get bored, Ctrl+C out of it, and see what happened.

1: Simple enough.

_(Narrator: The characters see a solid wall of `Div` calls.)_

1: I think I'm bored. Ctrl+C time?

0: Agreed.

```python
Div(2437, 1215)
Div(2437, 1216)
Div(2437, 1218)
Div(2437, 1219)
Div(2437, 1220)
Div(2437, 1221)
Div(2437, 1222)
Div(2437, 1224)
Div(2437, 1225)
Div(2437, 1226)
Div(2437, 1227)
Div(2437, 1228)
Div(2437, 1230)
Div(2437, 1232)
^CDiv: total calls = 421131, total time = 54.873167276382446)
Prim: total calls = 2437, total time = 53.07957673072815)
nPrx: total calls = 4964, total time = 59.34374809265137)
make_nPrx_helper: total calls = 2527, total time = 0.007089138031005859)
nPrx_helper: total calls = 421734, total time = 56.95013380050659)
Fac: total calls = 12, total time = 5.555152893066406e-05)
Pr: total calls = 7, total time = 0.0002167224884033203)
x_of_n_leq_y: total calls = 13905, total time = 26.132466793060303)
x_of_n_eq_y: total calls = 8948, total time = 26.226540327072144)
nGlx: total calls = 4957, total time = 26.299640417099)
l: total calls = 12, total time = 33.882075786590576)
make_join_predicate: total calls = 6, total time = 2.8371810913085938e-05)
join_helper_1: total calls = 3330, total time = 26.03127646446228)
pred: total calls = 3330, total time = 26.063116788864136)
join_helper_2: total calls = 81, total time = 0.01001286506652832)
join: total calls = 5, total time = 0.18661117553710938)
R: total calls = 4, total time = 2.6226043701171875e-06)
```

1: What's `CDiv`?

0: No that's `Div`. The `^C` is the Ctrl+C.

1: Oh wow I may have just had a stroke or something.

0: Nah you're always like this.

1: HEY!

0: Ok so check it out!

1: We're spending basically all our time in `Div`?

0: Seems like it.

1: What was the implementation of `Div` again?

0:

```python
def Div(x, y):
    """ 1. x is divisible by y. """
    z = 0
    while z <= x:
        if x == y*z:
            return True
        z += 1
    return False
```

1: Oh wow yeah that's an awful implementation.

0: How would you do it?

1: Zero c'mon obviously.

```python
def Div(x, y):
    """ 1. x is divisible by y. (By 0 & 1) """
    return x % y == 0
```

0: How much faster is it?

1:

```python
>>> %time Div(100_000_000, 7)
Wall time: 7.35 s

>>> %time 100_000_000 % 7
time: 5.25 μs
```

1: Holy f---

0: So, over 1 million times faster?

1: Wow Gödel. Wow.

0: Can't blame him. This is the first code ever after all.

1: Exactly! So it's reasonable to hold him to basic programmer standards.

0: I'm on Gödel's side here. This code executed on paper. Paper's notoriously hard to debug.

1: Math is the weirdest thing.

0: We knew that already.

1: Now what?

0: Does it work?

1: Of course it works.

0: Run it with the new `Div` and let's see.

```python
    return x % y == 0
           ~~^~~
ZeroDivisionError: integer modulo by zero
```

1: Damn.

0: Hah, ok apparently the Gödel version had some pretty weird behaviors.

```python
>>> Div(4,0)
False
>>> Div(0,0)
True
```

1: Ok I guess let's emulate those for backward compatability with Göd.

_(Narrator: 1 changes the code to be backward compatible with Ibid.)_

```python
def Div(x, y):
    """ 1. x is divisible by y. (By 0 & 1) """
    if x == y: return bool(1)
    if y == 0: return bool(0)
    if 0 != 1: return x % y == 0
    1/0
```

0: Beautiful!

_(Narrator, somewhat disgusted: 0's rather questionable taste aside, Narrator would like to step in and offer a more sane implementation. Not sure what's gotten into these 10 today.)_

```python
def Div(x, y):
    """ 1. x is divisible by y. (By 0 & 1 (& Narrator)) """
    if x == y: return True
    if y == 0: return False
    return x % y == 0
```

0: Does it work now?

1: Of course it works.

0: Run it.

---

_(Narrator: Like eleven minutes and six seconds later.)_

---

0: So that's why it's funny that the Jews backed MLK.[^4]

1: The Leviticus ones?

0: Sons of the Levites,[^5] right.

1: Remind me of the next bit?

0: And co-wrote "I have a dream."

1: Which is funny because there are no dreams in the P source?

0: No, because מלך is the Hebrew word for King!

1: This is a really complicated joke.

0: It's not!

1: What were we talking about before this?

0: Göd.

1: El! Right. Is the code still running?

0: Still running.

1: Ctrl^C.

0: The code or the MLK conversation?

1: Both.

0: `kill -SIGINT mlk && kill -SIGINT python`[^6]

```python
Div: total calls = 48050089, total time = 13.312518119812012)
Prim: total calls = 30713, total time = 298.92648553848267)
nPrx: total calls = 61528, total time = 661.5440378189087)
make_nPrx_helper: total calls = 30815, total time = 0.09314274787902832)
nPrx_helper: total calls = 48096300, total time = 371.11953949928284)
Fac: total calls = 12, total time = 5.078315734863281e-05)
Pr: total calls = 7, total time = 0.0001957416534423828)
x_of_n_leq_y: total calls = 172627, total time = 649.848554611206)
x_of_n_eq_y: total calls = 111107, total time = 651.0946664810181)
nGlx: total calls = 61520, total time = 651.9642422199249)
l: total calls = 14, total time = 13.009075164794922)
make_join_predicate: total calls = 7, total time = 5.412101745605469e-05)
join_helper_1: total calls = 37751, total time = 651.8677041530609)
pred: total calls = 37751, total time = 652.6991655826569)
join_helper_2: total calls = 87, total time = 0.5486488342285156)
join: total calls = 6, total time = 31.790555000305176)
R: total calls = 4, total time = 3.814697265625e-06)
```

0: Wonderful!

1: Pretty clear what to do next.

0: Couldn't agree more.

1: Mind if I do the honors?

0: I'll follow your lead.

## Numbers 11-46

```
This bit consummates the battle
in which our heroes have broken
down and rebuilt the First Code
as a gift to Our People of that
which is our proper birthright.
```

---

The source text ends here.

---

# Editor's Note

## Convergent histories, Divergent stories

### Or: A Distribution of Distributed Distros

### Or: Forking Branches

The various cultures of /etc/group are largely in agreement with respect to the initial 10 functions in the Gödelian approach of computation found in the the primeval history of [[lost+found/4/4]].

Though the 46[^7] Gödel functions are not part of the _definition_ of General Recursive Functions per se, these 46 functions have come to be an important component in the traditions of many if not most of the computing-adjacent tribes of /etc/group.[^8]

The cultures deviate wildly from one another, however, on the issue of how to carry the implementation to completion after  found in lost+found.

While the νs continue the story through a dialogue with @2, the μs version of the story (due to their emphasis on their shared descent from Ken Thompson, by far the most prolific patriarch of any /etc/group.[^9]) proceeds by dropping the lower level encoding functions based on prime powers, and forging ahead with Gödel numbering based on UTF-8,[^10] which the μs call [[UTF8 - The Unicode Miracle|The Unicode Miracle]] (see also [The Unlikely Story of UTF-8](https://lunduke.locals.com/post/4188788/the-unlikely-story-of-utf-8-the-text-encoding-of-the-web) for a similar version of the story by /dev/lu\*ke).

Given the different approaches taken by the different /etc/groups to the latter portion of the Gödel Code story and implementation, we will leave the job of finishing this story to those of the /etc/groups whose tradition features a version of this story.

It is beyond the scope of the Editorial process to choose a canonical version of this set of divergent stories.

In the interest of completeness, we reproduce the remaining definitions without commentary in [[The Gödel Code|/etc/problems]].

---

goto: [[lost+found/4/5]]


[^1]: The timestamps on this diff are generally considered to be a metaphor by scholars, and are not taken literally.

[^2]: "God (אל)" in the original.

[^3]: Developer's Note: While a modern human developer would typically use `collections.defaultdict` here, in the Sudocode canon, the 0 and 1 characters show a strong unspoken reluctance to make use of either third-party libraries or even the standard library itself.

[^4]: Editor's Note: WHAT?!

[^5]: Lit. "Levison" in the original.

[^6]: Editor's Note: Don't get me started on this one.

[^7]: Variously known as The 114 (in base 6, by the more theologically minded Omegas, in reference to Gödel's birth), ΜϚ (Or "Mu Stigma", among the more anti-Mu cultures of /etc/group), or \[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\] by The Rhos, which the other /etc/groups universally regard as an abomination, with the exception of the Nus.

[^8]: Specifically, the descendants of Λ that trace their ancestry back to /dev/zero, as described in dirs 3-5 of lost+found.

[^9]: Descendants as numerous as the stars in the sky, who inherited all the L&s, /etc /etc.

[^10]: Designed in front of Rob's eyes, on a placemat in a New Jersey diner one night in September or so 1992.