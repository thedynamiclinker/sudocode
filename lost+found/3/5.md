## (3,5): Church's Language

### Or: What Church was thinking
### Or: Church's First Try
### Or: Untyped λ-calculus
### Or: Premathematics of λ
### Or: Take Me To Church
### Or: Be My Church
### Or: BMC

0: Ok so in Church's system, everything is functions.

1: You've mentioned this already, but I still don't know what you mean.

0: How do you mean?

1: I mean if everything is functions, what do they take as inputs?

0: Functions.

1: What do they return as outputs?

0: Functions.

1: Zero?

0: What?

1: ... That's insane.

0: I know it feels that way at first. But it's not so bad once you implement numbers and booleans.

1: Sure sure, but WHY?

0: Why what?

1: Why do this at all?

0: Why are we doing it?

1: No why was Church doing it? I want to know what was going on inside his head, or at least what might have been. What would make a person say "Y'know what I'm gonna do today? Make a system where 0 and 1 are actually functions." Like that's not a normal behavior and it's not a natural way to think. So I'm curious what was going on in this guy's head that would make him do something like this.

0: Perfect question! Ok so, by the time Church is writing, formal theories had been a thing for a while. ZFC had already done formal set theory. PA had already done formal number theory. It's not unreasonable to think something like "Look guys, those theories you made are cute and all, but the foundations of mathematics or even reasoning itself shouldn't be just whole numbers or unordered collections. The foundations of mathematics should be something more primitive."

1: What's more primitive than those things?

0: Well there are infinitely many natural numbers. And that's not a problem in itself, but we'd like our foundations to be something inherently finite. I mean when a mathematician proves stuff about the natural numbers by induction, they do it with only a finite amount of time and food and paper and pencils and erasers. Finite everything. Foundations should be like that. So it's fine that the natural numbers are infinite, but they're not finite in the same obvious way that the mathematician with the paper is finite and only doing finite stuff. If we truncate the natural numbers at any finite level and say "There are no natural numbers above ten million" or whatever, any mathematician would rightly feel like we'd done a violent ugly hack that made the natural numbers less of what they are. But there's no such feeling when a mathematician uses only finitely many pencils or finitely many sheets of paper. We have no problem with that, and we'd be disturbed if either was infinite. So in that sense natural numbers are way too big to be foundations.

1: What about sets? Sets can be finite.

0: True! But all versions of set theory that have ever been proposed as foundations are much more infinite than the whole numbers are. They tend to all include a sentence that says "ω exists."

1: You mean ω like Cantor's first size of infinity?

0: Well in this case it means "The set of natural numbers," but those are actually the same thing.

1: How are those the same thing?

0: Well no finite number is big enough to be the smallest infinite number. So the set of all natural numbers ends up being the same thing as "the smallest infinite number" in that system. Anyways things are even worse in set theory than in number theory, because there tends to be another axiom that says "If a set X exists, then so does P(X), the set of all its subsets." And that P(X) turns out to always be a bigger size than X, even if X is infinite. So any formal theory that had these two things together grows an infinite number of different sizes of infinity, each larger than the next.

1: I remember. So what was Church thinking?

0: Well taking together both the fact that (i) the natural numbers have an inherent inability to be made finite without it feeling like an ugly hack, and (ii) set theory has such a wildly irresponsibly number of infinite things that it's not clear how it got invited to the foundations party... taking those two things together, you might end up thinking what Church was thinking.

1: _(Narrative voice)_ "So what was Church thinking?, 1 asked yet again."

0: That we need a "Formal Theory of X" for some better X than just X = numbers and X = sets.

It should be something fundamentally finite.

Maybe there's infinitely many Xs for whatever this sought after X type thing is, but it should be possible to _make_ the theory only about finitely many objects made of inherently finite stuff, and finitely many operations on those things. We should be able to "finitize" the theory without it feeling like an awful hack in the way it would be if we said 1 million is the largest natural number.

1: "Without it feeling like"?

0: Yeah, what's the problem?

1: You seem to be suggesting that Church wanted something finite, but his foundation for wanting that was "feelings."

0: Of course. I mean I never knew Church specifically, but that's a totally normal way to think when you're doing mathematics.

1: The more you talk about math, the less I understand what it really is.

0: Good. That means you're listening. So anyways if you thought all the thoughts above, you might end up doing what Church did, so let's do our best to get inside his head.

We're looking for some type of X where we can build a "Formal Theory of X" that doesn't feel fundamentally broken if we don't have infinitely many of them, or if the guts of each one aren't infinite either.

Sure there might be infinitely many Xs for this sought after value of X, but there shouldn't NEED to be.

We're looking for something like that.

Something fundamentally finite or at least something that we could force to be finite without it feeling like the hack job of truncating $\mathbb{N}$. 

Our X should be more general than numbers or sets.

Something that's hiding in plain sight all around us if we could just open our eyes and see what X is.

Something that's painted all over every sentence in every area of mathematics, both the discrete areas like number theory and combinatorics and graph theory, and the continuous areas like calculus and geometry and topology.

Our X should be staring us in the face whenever we open any textbook, and when first hear someone say what it is we should feel a feeling of "Damn. Of course. Why didn't I think of that?"

1: Seems reasonable. What kind of thing is like that?

0: You tell me.

1: Functions?

0: Functions.

## How to Write Good

### Or: Formal Function Theory
### Or: Church & Kleene
### Or: Be my repl

0: Ok, so now do we understand why a person might do something like this in the first place?

1: Totally.

0: Ok so Church's notation for functions was λx---

1: You don't have to explain lambdas. I'm a professional developer.

0: Great! So with that notation in hand, Church defined the natural numbers like this:

0 := λf. λx. x
1 := λf. λx. f x
2 := λf. λx. f (f x)
3 := λf. λx. f (f (f x))
4 := λf. λx. f( f (f (f x)))
succ := λn. λf. λx. f (n f x)

1: Back up, I'm not ready for that yet.

0: You're not ready for the definition?

1: No.

0: What do you mean?

1: I mean that definition makes no sense to me. Back up to the part where they derive that.

0: Derive what?

1: The definition.

0: Church doesn't do that in this paper.

1: Ok can we find a textbook that does?

0: Sure, let's go look.

_(Narrator: 0 and 1 go find some other textbooks on λ calculus.)_

0: This one doesn't have it.

1: Same with this one.

0: Y'know I've actually never seen the kind of derivation you're asking for before.

1: Well what did Kleene use as a repl? 

0: He didn't have a repl.

1: How did he know if something he tried worked or not?

0: I think Church was his repl.

1: Well we can't do that! He's not here. And his paper isn't finished.

0: Don't blame Church, this is just how mathematicians write.

1: I thought he was a foundational person.

0: He is. I just mean if you publish in academic journals you have to write that way. It's basically required. You can write _about_ almost anything. All the journals consistently care about is that you write in an academic sounding way.

1: You're not allowed to write good?

0: You're definitely not allowed to write good in journals. They think that's wrong, and it's only right to write "well." Usually they care less about what you say and more about how you say it. And that makes it basically impossible to explain certain things, like what sorts of thoughts you'd have to have and what sorts of mistakes you'd have to make before you arrive at the definitions that you eventually use to prove stuff from. You're allowed to explain the part after the definitions, because it's possible to write that part well. But you're not allowed to explain the part before the definitions, at least not the parts that can only be explained good. If a thing can only be explained good and not well, you're not allowed to explain that thing.

1: You're not allowed to explain things?

0: You're allowed to explain things, but they have to sound formal.

1: I thought most mathematics wasn't formal.

0: No not "formal" as in formal languages. The journals don't care about formal languages and they certainly don't expect you to write in a formal language. They just want you to write in formal language.

1: I'm gonna scream.

0: I mean fancy English. Or natural language. They just want it to sound fancy.

1: What's the point of that?

0: I don't know, it's a bug that tends to show up in institutions that are culturally overvalued. Whenever a system or group has more social status than it deserves, it always starts talking fancy and insisting the big words matter and anyone who doesn't use the right words is inherently less sophisticated. It's a defensive position. It's not my cup of tea, but one can see where they're coming from.

1: That's fucking ret\*rded. Be my repl.

0: How so?

1: I'll write stuff. You tell me if it's a syntax error or not. Then when I plug things into functions, you evaluate them.

0: Let's split the work of evaluating them 50/50 and you've got a deal.

1: Great!

0: Ok I'm ready when you are.

1: x

0: (Says nothing)

1: So?

0: What do you want me to say?

1: I dunno, say yes if it's ok, or error if it's an error. Is that ok?

0: yes

1: x

0: yes

1: x y

0: hmm

1: That's not very repl of you.

0: I'm thinking.

1: About what?

0: I don't know if that's syntactically valid.

1: I thought you knew this system.

0: I mean, you have a free variable, and then you plugged it into another free variable. They're both functions. Cuz everything's functions. But neither of them has any lambdas in it. So I guess it's syntactically ok, but we can't reduce it any further. It just sort of sits there.

1: Ok, what about this.

λx. x

0: That's ok.

1: What about λx: 3

0: There's no 3 yet.

1: Oh right. How about this?

λx. y

0: That's ok.

1: You're supposed to say yes.

0: yes

1: λx. λx. x

0: error

1: Why?

0: Try plugging something into it.

1: What something?

0: Idk, like 3.

1: I thought there was no 3 yet.

0: Treat it like a variable.

1: What?

0: I just mean plug something into that thing you just defined. Something that doesn't feel like a variable, so you don't get confused.

1: 

(λx. λx. x)(3)

= λ3. 3

0: You can't do lambda of three.

1: Why not?

0: 3 isn't a variable.

1: I thought you said treat it like a variable.

0: Ok nevermind. Use a.

1:

(λx. λx. x)(a)

= λa. a

0: Now plug a into this: λx. λy. x

1: 

(λx. λy. x)(a)

= λy. a

1: What's was the point of that?

0: You got different things. In the (λx. λx. x)(a) example, the "a" got captured by the second lambda thing.

1: What?

0: Umm, one sec, I need to think.

1: Ok this isn't helping. Here let's back up.

0: I don't think we can back up further than this.

1: Of course we can.

0: How?

1: You said this was the first programming language right?

0: Yeah.

1: So obviously there's a bit before this.

0: Before what?

1: Before using it. I'm using the repl. That's WAY past the beginning of a language!

0: What comes before x and λx. x?

1: Implementing the language dummy.

0: Oh right.

## The Premathematics of Lambda
### Or: The implementation of λ lang

0: Where should we start?

1: Definitely not at numbers. That definition from earlier scared me.

0: How can we do anything without numbers?

1: I dunno, I feel like most of programming isn't really about numbers.

0: Good point. Where should we start then?

1: I'd prefer to start with programming.

0: In the language we haven't written yet?

1: Of course!

0: How can we write in the language if we haven't written the language yet?

1: Y'know. Pseudo-code.

0: Love it!

1: Ok so if we're gonna start with programming, first we need `if`.

0: I'll follow your lead.

1: How do I start?

0: We're supposed to implement `if`.

1: In what?

0: In functions!

1: How is `if` a function?

0: It's not. But we need to make it be one. Cuz all we have is functions.

1: Ok, um...

```
def if(???):
	return what?
```

1: I'm definitely stuck.

0: No you're not! That was a great start.

1: How was that a great start?

0: Because now the rest is obvious. Here watch:

```
def if(if, then, else):
	if if
	then then
	else else
```

1: What the hell is going on in that code?

0: I mean if `if` is a function, then it takes three things:
1. A boolean called `if`.
2. A code block called `then`
3. A code block called `else`

1: Can we call the boolean something different? This is hurting my head.

0: Sure, refactor however you want.

1: Ok how's this?

```
def if_then_else(condition, then_do_a_thing, else_do_b_thing):
	# Ok this is gonna be a problem...
	# Ummmmmmmmmmmmmmmmmmmmmmmmmmmm...
	if condition: # TODO: Implement if
		return then_do_a_thing
	else: # TODO: See above
		return else_do_b_thing
```

0: Great!

1: Zero that was a joke. Obviously I can't use `if` to implement `if`. I just got stuck and gave up.

0: I don't think you got stuck at all! Here let's re-write it in Church.

1: What?

0: I mean that pseudo-code looks like python. If we re-write your pseudo-code in Church, it sort of makes sense. Watch:

```
if_then_else = λcλaλb.c a b
```

1: What the hell's going on there?

0: It's just an abbreviation for your code. It means this:

```python
def if_then_else(c, # ondition
				 a, # a thing to do if c is true
				 b, # b thing to do if c is false
				 )  # that's it.
```
0: See?

1: But you didn't write the function body. That's just the signature.

0: The body is the same.

1: Same as what?

0: The signature! Look:

```python
def if_then_else(c,
				 a,
				 b,
				 ):
				 return (c
						 a
						 b
						 )
```

1: Is this actually an idea or are you just stalling for time?

0: It's your idea! I'm just rewriting your implementation by making the variable names shorter.

1: But my implementation was a joke. I used `if` inside of `if`. That was cheating.

0: Well obviously we need to use `if` inside of `if` or else it won't act like `if`.

1: Come again?

0: I mean unless we do something iffy in the implementation then it won't be iffy enough to act like if!

1: I agree that this is iffy.

0: Here look. It's already there in the code. I'll reformat it so it's clearer.

```python
def if_then_else(c, a, b):
	return c a b
```

1: What does that `return c a b` mean?

0: Oh sorry, in the top line I was writing python-y but then on line two I accidentally slipped back into my native language.

1: What?

0: The shell! I was trying to write a normal function call, I just pronounced it with a shell accent.

1: I still don't see how this is `if`.

0: It's obviously `if`! Here look:

```python
def if_then_else(c, a, b):
	return c(a, b)
```

1: I'm even more confused now.

0: Look back at your definition.

_(Narrator: 1 looks back at 1's definition.)_

1: I don't see how this helps.

0: Here I'll rewrite it.

```python
def if_then_else(c, a, b):
	if c:
		return a
	else:
		return b
```

1: It's still iffy.

0: It better be. If it's not iffy it's not if!

1: Can you stop with the puns and explain how your thing is my thing?

0: Pass a bool into both.

1: We didn't implement bools yet.

0: Well we also didn't implement errors so it's guaranteed to work!

1: You're the weirdest programming teacher.

0: Just do it.

1: Ok...

```python
##################
### Your thing ###
##################

def if_then_else(c, a, b):
	return c(a, b)

# Now let's pass in `true`,
# even though we didn't
# implement it yet
if_then_else(true, a, b)

# the true goes into the
# function and becomes
return true(a, b)

# which is just
true(a, b)

# Um...
# Ok I'm stuck. Let's go do mine.

################
### My thing ###
################

def if_then_else(c, a, b):
	if c:
		return a
	else:
		return b

# Pass in a true
if_then_else(true, a, b)

# the true goes into the function body
	if true:
		return a
	else:
		return b

# this one's easier to reason about.
# obviously this is just
return a

# which is just
a
```

1: Did I do it right?

0: Did you get any errors?

1: We didn't implement errors.

0: Well we didn't implement `if` either but you just used it twice. Any errors?

1: No.

0: Great! I'd say we're on the right track.

1: I still don't understand your implementation.

0: Do you understand yours?

1: Yes, but mine was cheating.

0: Well mine's the same as yours, but mine isn't cheating.

_(Narrator: 1 looks back at 0's if)_

```python
def if_then_else(c, a, b):
	return c(a, b)
	
>>> if_then_else(true, a, b)
true(a, b)
```

1: How is yours the same as mine?

0: Well it better return `a` like yours did or else it's not `if`. Because yours is definitely `if`. And yours returned `a`.

1: So yours behaves like this?

```python
>>> true(a, b)
a
```

0: I think it has to.

1: But we didn't define `true` yet.

0: I think we just did.

1: How?

0: Well `true` had better take two variables and return the first one.

1: What do you mean "had better"?

0: Well if it doesn't act like that, then my `if` doesn't act like `if` and I'm gonna have to start over. But if it does act like that, then I already implemented `if` and `true`, so the number of things I've implemented is either zero or two, and I'd prefer the latter, because in that case I'm ahead of you.

1: _(Skeptical)_ I feel like you're getting ahead of yourself.

0: Good point, we haven't done `false` yet. And until we have `false`, we can't say we're done with `if`.

1: How do we implement `false`?

0: I dunno. Pass it in.

1: I would remind you that we didn't implement it yet, but your weird backwards reasoning seemed to work last time, so what the hell...

```python
# Mine obviously does this:
>>> if_then_else(false, a, b)
b

# And yours is weird, same as before
def if_then_else(c, a, b):
	return c(a, b)
	
>>> if_then_else(false, a, b)
false(a, b)
```

1: What's `false(a, b)`?

0: Well it had better be `b` or I'm gonna have to start over.

1: Who decides if it gets to be `b`?

0: I think `false` gets to decide.

1: Who gets to decide how to implement `false`?

0: I think we do. Here look.

```python
def false(a, b):
	return b
```

0: And now we've implemented `false` too!

1: I'm kind of mad that this keeps working for you.

0: You're mad that it keeps working for _us._

1: How do we know if we cheated?

0: What do you mean?

1: I mean we're supposed to be implementing Church's λ language, but so far we've been speaking slang and pseudo-code and it all feels a bit iffy.

0: It had be---

1: Yes yes. How do we check if this all works in Church?

0: Well, let's write the same thing in Church and see if it works.

1: How will we know if it works?

0: I guess we'll have to use the language.

1: Again, I would complain, but this seems to be working.

0: I'll follow your lead.

1: What do you want me to do?

0: Take the iffy stuff we just did and say it in Church.

1: This?

```python
def if_then_else(c, a, b):
	return c(a, b)
```

0: Yeah.

1: How do I say it in Church?

0: Easy.
1. `sed s/def //g`
2. 1. `sed s/function_name/function_name = /g` (and then apologize and say "We don't technically have equals but I'm going to do it anyway", which is what everyone does)
3. `sed s/(/λ/g`
4. `sed s/, */λ/g`
5. `sed s/)//g`
6. `sed s/:/./g`
7. `sed s/return//g`

1: Simple enough.

_(Narrator: 1 runs the seds.)_

1: Ok I did everything you said. Here:

```
if_then_else = λcλaλb.
	cλaλb
```

1: Is that right?

0: No.

1: Where did I mess up?

0: You didn't. My instructions were wrong, but we're like four backspaces and two spaces away from this being valid Church. Here:

```
if_then_else = λcλaλb.c a b
```

1: What's going on here?

0: It's just Church-lang. Same idea as this:

```python
def if_then_else(a,b,c): return c(a,b)
```

or equivalently:

```python
if_then_else = lambda c,a,b: c(a,b)
```

but technically in order to be Gramatically Correct Church (or gcc) that compiles correctly (or cc) we have to replace all the multiple argument functions with single argument functions returning functions, like this:

```python
if_then_else = lambda c: lambda a: lambda b: c(a)(b)
```

1: _(Looking back at the iffy stuff.)_ How do we know if it worked?

0: I think we have to use it.

1: How do we use it?

0: I dunno, pass in a `true`.

1: Into what?

0: This:

```
if_then_else = λcλaλb.c a b
```

1: Ok...

```
# if we take the code here:
if_then_else = λcλaλb.c a b

# and pass in a true, we get
if_then_else(true) = λaλb.true a b = ?...
```

1: I'm confused. Why are there still λs in there?

0: You forgot to pass in two code blocks that tell the `if` what to do.

1: We didn't implemen--- Nevermind. I'm seeing a pattern here.

0: Pick up where you left off.

1: Ok, so let's pass in two imaginary code blocks `A` and `B` that say what to do when the condition's true or false.

```
if_then_else(true)(A)(B)
= (λcλaλb.c a b)(true)(A)(B)    # by definition
= (λaλb.true a b)(A)(B)         # pass the true in
= (λb.true A b)(B)              # pass the A in
= (true A B)                    # pass the B in
= true A B                      # this is probably allowed, idk...
```

1: Now what?

0: Well we already defined `true`, now we just say it in Church, like this:

```python
# In the pseudo-code from earlier (non Church lang)
>>> true(a, b)
a
```

0: In Church lang, we pronounce it like this:

```
true = λaλb.a
```

1: How do I use that?

0: Plug it into true.

1: Plug true into true?

0: By definition!

1: All your worst nonsense somehow makes more sense than your best non-nonsense.

0: That's how truth works! Now show me how true works.

```
if_then_else(true)(A)(B)

...                             # all those steps I did above

= true A B                      # now let's plug true into true ._.
= (λaλb.a) A B                  # plug in the `then` code path
= (λb.A) B                      # plug in the `else` code path
A                               # I think this means it worked?
```

0: Of course that means it worked!

1: "Of course" how?

0: We plugged a `true` into `if` and the `then` branch popped out!

1: So if we pass `false` in we get `B`?

0: We better! If not, that wouldn't be very iffy.

1: Here I'll check, I think I'm getting the hang of Church language.

```python
# This was our `false` in pseudo-code
def false(a, b):
	return b

# So if we pronounce that in Church, we say
false = λaλb.b
```

1: Now let's plug `false` into the `false` slot of `if` and toss two pretend code blocks in too, same as before:

``` 
if_then_else(false)(A)(B)
= (λcλaλb.c a b)(false)(A)(B)   # by definition of if_then_else
= false A B                     # i'll just plug all three in this time
= (λaλb.b) A B                  # by our definition of false
= (λb.b) B                      # plug in the A
= B                             # now (λb.b) is the identity function, so we get B
```
0: It's false!

1: I messed up?

0: No! I mean our false worked like false. It's a true false!

1: I'm kinda surprised but this is actually making sense.

0: 1derful! Onward!

1: What should we do now?

0: I dunno, maybe we're ready for numbers?

1: How were zero and one defined again?

0: I think that's up to us.

1: Good call.

0: 1st lets implement numbers. But 0th let's recap what we've implemented so far.

```
##############################
### the λ standard library ###
### by 0 and 1
##############################
if    := λa. λb. λc. a b c
true  := λa. λb. a
false := λa. λb. b
```

1: Wild.

0: What?

1: Until you renamed the variables, I didn't realize `if` was `λa. λb. λc. a b c`.

0: What's wrong with that?

1: It's like... nothing.

0: Not true. Zero is nothing. We didn't define zero yet.

1: I mean it's so minimal. It's like essentially not defined.

0: Not true. Not's not defined yet. Nor are And and Or and Nor.

1: ZERO STOP RECURSING!

0: It's hard in λ lang. Everything's a recurse word.

1: I hate you.

## Numbers

1: Ok this time don't give away the answer. I want to try it myself and see if I get it right.

0: I'm afraid that's not how this works.

1: You're gonna tell me the answer against my will?

0: No, I mean it's not up to me to say what's right. We're implementing the language remember?

1: But how will we know if we get it right?

0: Same as any code. We just have to use it and see if we hate it enough to refactor.

1: Makes sense. Where do we start?

0: Well I think I'll start with zero and one. You can start with whomever you like.

1: You're an idiot.

_(Narrator: 0 and 1 each work independently on their own definitions of zero and one.)_

1: Got one.

0: One sec, I'm not done typing yet.

_(Narrator: The 0 character types a few more characters.)_

0: Ok I'm done.

1: How did you do it?

```
0 = λaλb.b
1 = λaλb.a(b)
2 = λaλb.a(a(b))
3 = λaλb.a(a(a(b)))
```

1: 
```
0 = λa.a
1 = λa.a(a)
2 = λa.a(a(a))
3 = λa.a(a(a(a)))
```

TODO: Add a few lines where they wonder how we can tell which definition is better? Answer: Have to do something with the numbers.

## How to succ

```
3 = λa.a(a(a(a)))
```

Isn't `succ n` just

```
succ n = a(n)
```

So like

```
4 = a(3)
```

Or for your definition, since

```
3 = λfλx.f(f(f(x)))
```

Wouldn't we just have

```
4 = f(3)
```

Like wrap one more copy of the function around it?

0: I dunno, substitute in the definitions of 3.

1:

```
4 = a(λa.a(a(a(a))))
```

1: I'm confused. Is having the lambda inside like that is allowed? This feels wrong.

0: Hey 1, I made progress! Come look!

_(Narrator: 1 goes over to see what 0 accomplished.)_

1: Zero, you just wrote

```
succ n = ?
```

1: That's not progress.

0: I think it is.

1: Ok then.

_(Narrator: 1 quickly writes a few characters.)_

1: _(Sarcastically)_ "Hey 0 I made progress."

0: Great! Let me see.

_(Narrator: 0 goes over to see what 1 accomplished.)_

0: Beautiful!

1: _(Confused)_ I was being sarcastic. I didn't do anything.

0: Sure you did!

1: Zero, I literally just wrote

```
succ n = m
```

1: I was making fun of you. This isn't progress.

0: I think it's wonderful progress.

1: You're acting weird again. Why is this 1derful?

0: Well we haven't agreed on which definition of numbers to use yet, but we each have our own definition, so I can do this:

```
succ = λn λ? λ? (stuff)
```

1: Explain?

0: Well whatever succ is, we know it takes an number n and spits out a number m. So I turned

```
# this
succ n = m

# into this
succ = λn (stuff)

# and since it spits out a number m,
# that (stuff) bit has to be a number,
# and since numbers in my definition
# are two argument functions, I wrote
succ = λn λ? λ? (stuff)
```
1: Are those question marks the same question mark or different question marks?

0: Different. I guess that wasn't clear. Here:

```
succ = λn λf λx. (stuff)
```

0: This isn't really saying anything new. It's just the idea that succ returns a number too, and my numbers are functions of two arguments. Now we just have to implement the `(stuff)`!

1: Isn't that the entire problem? How is this progress?

0: Or course it's progress! Now we know how to undress the numbers!

1: Un-what the who now?

0: You had a good idea about wrapping the function around one more time, but you were wrapping it around the outside. Now that the numbers are naked, no more lambdas wrapped around them, maybe we can add the extra copy of `f` down here.

1: Like how?

0: Watch.

```
succ = λn λf λx. f(n)
```

1: Wait I think this has the same problem as mine. That `n` has lambdas on it.

0: Show me?

1: Here look.

```
3 = λf λx. f(f(f(x))
```

So

```
3 g y = g(g(g(y)))
```

0: What are `g` and `y`?

1: I used different letters because I wasn't sure if I'm allowed to plug `f` and `x` into a thing that already has those.

0: I think it should be ok.

1: Ok then I just meant this:

```
3 f x = f(f(f(x)))
```

0: Great! Or in general:

```
n f x = naked n
```

0: So now

```
succ = λn λf λx. f(naked n)
```

Or

```
succ = λn λf λx. f(n f x)
```

1: Ok wait, in my definition of numbers, I'd have:

```
succ = λn λa. a(naked n)
```

Or:

```
succ = λn λa. a(n a)
```

0: Wonderful! We're done!

1: With what?

0: We both know how to `succ` any number.

1: But we didn't even agree on how to define numbers yet.

0: That ok! Even if we're succ'ing different things, at least we're both succ'ing something.

1: Now what?

0: Well what else can we do with two numbers?

1: The usual stuff I guess. There's:

- addition
- multiplication
- exponentiation
- should we do subtraction maybe?

## This should go somewhere in the succ section or deleted

1: Why not this?

```
succ := λn. λf. f n
```

0: I dunno, let's see how it works:

```
succ 2 = (λn. λf. f n)(λf. λx. f (f x))
       = λf. f (λf. λx. f (f x))
       oops I mean
       = λf. f (λg. λx. g (g x))
```

1: Ok that looks weird, I dunno how to think about what's going on here.

0: Let's start over. You're trying to define something like this right?

```
0 ≈ x
1 ≈ f(x)
2 ≈ f(f(x))
3 ≈ f(f(f(x)))
```

1: Why the squiggly equals signs?

0: I just meant "You're trying to do that, but without the f and x being free variables" right?

1: Yeah exactly.

0: So let's just toss some lambdas outside.

1: What's the point of that?

0: I dunno. It'll get rid of the free variables.

1: Ok, here:

```
0 := λf. λx. x
1 := λf. λx. f x
2 := λf. λx. f (f x)
3 := λf. λx. f (f (f x))
4 := λf. λx. f( f (f (f x)))
```

0: What's +1
1: Just wrap another f around it.
0: Around the outside?
1: No, around the inside.
0: How do we do that if we only have 3 system calls?

(Insert some glue code about what the system calls are.)

Lambda Calculus System Calls:

There's only one type, but we're gonna pull an Alonzo Church and give the one type 3 different names below, depending on how we're thinking about it. It's really all the same type though. Everything's Alonzo Church. I mean functions.

```
1: mkvar: takes a string, makes a var
2: mkfun: takes a var x and an expr e, makes λ x: e
3: rmvar: takes a fun f and an expr e, makes f e (plugs it in)
```

1: I don't think number having free variables inside them is any weirder than numbers having parameters that you can pass stuff into.

1:

```
succ 1
= (λn. λf. λx. f (n f x)) 1
→ λf. λx. f (1 f x)
→ λf. λx. f ((λf. λx. f x) f x)
→ λf. λx. f ((λx. f x) x)
→ λf. λx. f (f x)
```

1: And that's two!

1: Addition. Explicitly. Once.

0: Define:

```
plus := λm. λn. λf. λx. m f (n f x)
```

Compute `plus 1 2`:

```
plus 1 2
= (λm. λn. λf. λx. m f (n f x)) 1 2
→ (λn. λf. λx. 1 f (n f x)) 2
→ λf. λx. 1 f (2 f x)
→ λf. λx. (λf. λx. f x) f ((λf. λx. f (f x)) f x)
→ λf. λx. (λx. f x) ((λx. f (f x)) x)
→ λf. λx. f (f x)   -- Wait, I think I messed up.
```

1: Wait, we computed `1 (2 f x)`, which should be `f` wrapped around `(2 f x)`, i.e. `f (f (f x))`.  
Fix the step-by-step carefully:

Re-do the last three lines more slowly:

0: Ok, let's go slower.
```
λf. λx. 1 f (2 f x)
= λf. λx. ( (λf. λx. f x) f ) ( (λf. λx. f (f x)) f x )
→ λf. λx. ( (λx. f x) ) ( (λx. f (f x)) x )
→ λf. λx. ( f ( (λx. f (f x)) x ) )
→ λf. λx. f ( f (f x) )
```

This is Church 3. Good.

1: Fine. Show me one example where α-conversion matters.

0: Reduce `(λx. λy. x) y` applied to `y`:

```
((λx. λy. x) y) y
→ (λy. y) y         -- WRONG if we substitute naively!
```

We must rename the inner `y` to avoid capturing the free `y` used as an argument:

```
(λx. λy. x)  ≡  (λx. λz. x)   -- α-convert inner y to z
((λx. λz. x) y) y
→ (λz. y) y
→ y
```

Without α-conversion we would have (incorrectly) gotten `y` bound by the wrong λ.

## Y combinator

1: Recursion?

0:  The Y combinator:

```
Y := λf. (λx. f (x x)) (λx. f (x x))

Y g :=    (λx. g (x x)) (λx. g (x x))
    := g ((λx. g (x x)) (λx. g (x x)))   -- How did we get this again? Nvm.
	:= g (Y g)

Z = g (Z)
Z = g (g (Z))
Z = g( g (g (Z)))
Z = g( g( g (g (Z))))
...
Z = g( g( g (g (...))))

So

Y = λf. f( f( f (f (...))))

Y f = f( f( f (f (...))))
Y f = f(Y f)
Y = λf. f(Y f)
Y = λf. ((λx. f x) (Y f))
Y = λf. ((λx. f x) f(Y f))
Y = λf. ((λx. f x) ((λx. f x) (Y f)))  -- Ok we need to get rid of this Y somehow...

Y = λf (λx. f(x) f(Y f))

```

Show the key equation `Y f → f (Y f)`:

```
Y f
= (λf. (λx. f (x x)) (λx. f (x x))) f
→ (λx. f (x x)) (λx. f (x x))
→ f ( (λx. f (x x)) (λx. f (x x)) )
= f (Y f)
```

That's the whole trick.


goto: [[lost+found/4/1]]