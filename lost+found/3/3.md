#images-doctored
## (3,3): Inconsistencies and Arcana
### Or: Church's Thesis (Not that one)
### Or: Church vs the Old Laws
### Or: Church's Oldest Code
### Or: AC on AC

0: Ok, so the story of Church starts with Church's Thesis. Not the Church's Thesis you may have heard of. This is about the other Church's Thesis.

1: I don't know about anything called "Church's Thesis."

0: Well there's something else called Church's Thesis that we'll get to later. For now, we're not talking about that. We're talking about his PhD Thesis. The other Church's Thesis.

1: Why does everything related to Alonzo Church have multiple names for the same thing?

0: You mean multiple things for the same name?

1: Yeah that. What's with that?

0: It's just how Alonzo Churches work.

1: Seems to be.

0: So Church's other thesis (his PhD Thesis) was on the Axiom of choice.

1: What's that?

0: It's part of the standard foundations of mathematics. The orthodox machine code of the field. The Axiom of Choice is a sort of "constructor" for sentences that look like $\exists x P(x)$.

1: I know what a constructor is. What's the $\exists$ thing?

0: That means "There exists." The Axiom of Choice is a sort of constructor for sentences that say Something Exists. But it's a strange sort of constructor. It can give you a sentence that says $\exists x P(x)$ without requiring you to give an example of an $x$ that makes that sentence true. And you're allowed to take that sentence that says "Something Exists" and use that sentence in your proofs. It's part of the Generally Accepted Foundations of Mathematics[^1]. But at least in some circles it's controversial because you can call it (the constructor) and get the Existence proof without ever passing in any Something makes the sentence true.

1: I'm like 50% following. Rephrase?

0: It lets you prove that something exists without requiring you to give any examples.

1: WHAT?!

0: Yep. Sketchy right?

1: Well I'm not entirely following the mathematics but that definitely sounds sketchy.

0: Yep, that's what Church did his Thesis on.

1: Which Church's Thesis?

0: The PhD one. He was criticizing the Axiom of Choice.

1: Seems like a good idea for a thesis.

0: So Church writes his PhD thesis being like "Maybe we can delete this code guys, it's kinda sketchy."

<figure style="text-align: center;">
  <img src="church-04.png" alt="Church's Thesis (not that one)">
  <figcaption style="font-size: 11pt; padding-top: 0.3em;">
	From <i>The Collected Words of Alonzo Church.</i>
	<br>
	By Alonzo Church and Whoever Compiled
	<br>
	 <i>The Collected Words of Alonzo Church.</i>
  </figcaption>
</figure>

1: Why are we talking about the Axiom of Choice?

0: Well remember, by this time, it's been about 50 years since Cantor, and almost 30 years since 1900 when Hilbert announced his list of problems. So there's been a reasonable amount of work on the foundations of mathematics since then.

1: What was going on during the 30 years before Church's thesis (the PhD one)?

0: Well there had been some work on axiomatic set theory. Mostly on this system I mentioned up above called ZFC, or Zermelo Fraenkel (with the axiom of) Choice. That system is still considered the "official" foundations of mathematics by mathematicians today.

1: So what's the problem?

---

_(The document is missing a section here.)_

---

0: Ok so here's one of his early papers. If you read it, he's clearly bothered by "free variables" for some reason. But the sense in which he's using the term "free variables" means something a bit more like "information that we didn't include in the formal system." The bits we have to add in English after the symbols.

![[church-20.png]]

1: "Without the addition of verbal explanations." Love it!

0: That's what he's working on. Getting all the vagueness and natural language out of mathematics, at least in principle.

1: Y'know it's weird. I sort of assumed mathematicians solved that problem like... thousands of years ago.

0: Nope! Mathematics has always been a mixture of formal and informal. Church wants to see if it's possible to fully specify all the missing bits. If you read the part below closely, what he's calling "free variables" are really more like _type variables._ Notice how he starts with the sentence $a(b+c) = ab + ac$ and says the $a$, $b$, and $c$ are "free variables." Then he shows what it would mean to fix that sentence.

![[church-21.png]]

1: What's the bit with the $R(a)$s and the $\supset_{abc}$ ?

0: I think the notation is based on some old stuff Peano did. But it's not complicated.

1: Looks complicated.

0: Read it.

1: "Where $R(x)$ has the meaning '$x$ is a real number' and"... oh nevermind I feel dumb.

0: So what's Church saying here?

1: He's just saying we should add types to the variables so we know what kind of thing they are.

0: Exactly. And that tendency carried through from the 1930s to modern functional programming and why their languages tend to be strongly typed.

1: Seriously?

0: Yep. Functional programming languages are all descended from Church's first language.

1: The language where every type is Alonzo Church?

0: Functions, but yeah exactly.

1: Nice! Is that language in this paper?

0: Sort of...

1: What do you mean "sort of"?

_(Narrator: 1 flips ahead through the paper)_

![[church-collage-1.jpg]]

1: Holy F---

0: Yeah.

1: Why does it hurt my eyes?

0: Because you skipped ahead.

1: This is traumatizing. I changed my mind. I don't think I'm cut out for this "frighteningly technical" stuff after all.[^2]

0: Don't worry, a lot of that turned out to be inconsistent.

1: What?

0: Here look. About halfway through the stuff you just flipped through, Church shows up and goes _"Ok guys, so, this is awkward. Um, that first formal system from a little while back was inconsistent."_

![[church-27.png]]

1: Inconsistent how?

0: Like totally broken. You can prove anything.

1: Hahahahahaha all that hell math for nothing?

0: Not for nothing! Church ends up fixing the bug by adding "types." Which after all was sort of the thing he was on about in the introduction to the first paper.

1: How do you do all that hell math and then realize the whole system is broken?

0: One of his students found the bug.

1: Was it Kleene?

0: Yep.

1: It's always Kleene.[^3]

0: There was another guy named Rosser who helped with this one, but yeah, Kleene's everywhere.

![[church-37.png|400]]

1: This is even more "frighteningly technical" than the hell math from earlier.

0: Definitely. Kleene's way easier to read than this, in my opinion.

1: What's the point of all this? I mean if we're gonna be reading and writing this level of hell math there'd better be a good reason.

0: Ok well remember how the AC[^4] lets you prove something exists without actually, like, computing it or constructing it?

1: Yeah that seemed like cheating.

0: Ok so the point of the hell math above was that AC[^5] had gotten interested in how to define "computability." Back then they called it "effective calculability" or "effectively calculable" or "an effective procedure." That's actually the topic of Church's Thesis.[^6] But it just meant "Anything you can actually DO without cheating like how the AC[^7] cheats." Which remember was the topic of Church's Thesis.[^8]

![[church-06-1.png]]

1: What exactly is an effective procedure?

0: Exactly.

![[church-06-2-with-footnotes.png]]

1: When are we gonna get to the programming?

0: Right now.

1: Really?

0: Really. Read this next part carefully.

![[church-15.png]]

1: Didn't he start by saying "We need to get rid of free variables" in the other paper?

0: Yeah.

1: But he just introduced free variables into his system.

0: Good catch. He'll get rid of them soon. That's what the lambda is for.

1: It would help if there was more motivation.

0: Yeah, Church is sort of a joy and a pain in the ass at the same time. But this funny $\{F\}(X)$ notation is just a reverse-abbreviation for $F(X)$.

1: What are the curly braces for?

0: In case you want to put the implementation of the function in there instead of just its name.

1: Implementation how?

0: That's what the lambda thing is doing. Same lambda as in modern programming languages.

1: Oh, no way!

![[church-16.png]]

1: Ok I sort of get this now. So this is just lambdas? Like "lambda" lambdas?

0: Yep.

1: No numbers?

0: No numbers.

1: No booleans?

0: No booleans.

1: How can you do anything?

0: Well numbers and booleans aren't built in to the language, but they're still there. We just have to implement them from lambdas.

1: Sounds like a pain.

0: Well it was, but remember the only alternative back then was _Principia_ and a few other textbooks, so at the time even this system seemed pretty great compared to the alternatives. Ok so, back to Kleene.

> Steve Kleene: Well, I never read _Principia_. Of course I thumbed it a little bit... Rosser I guess started his logic that way... But I learned logic by learning Church's system which was subsequently proved inconsistent.
> 
> _(Everyone laughs)_

1: Why did everyone laugh there?

0: Inconsistent systems are supposed to be useless in logic. But that can't be entirely true because Kleene's one of the best logicians in the past century and he learned logic from a system like that.

1: Logic is trippy.

> Steve Kleene: And y'know, it all consists of abstract lambda definability. And uh, and it was only after I got my degree that I really began to read much of the litchrachoar.

1: What's "litchrachoar"?

0: Sorry, that's "literature."

1: Did he spell it like that?

0: No, this is an old audio recording.

1: So you spelled it like that?

0: I wanted to capture his accent.

1: Well don't.

0: Ok. Just imagine it. He's got a charming sort of unpretentious midwest thing going on.

> Steve Kleene: It was only after I got my degree that I really began to read much of the literature. Uh let me see. Hilbert Bernays, didn't the first volume of that appear in 1934?... Hilbert Bernays was around... I never read Lewis and Langford.

## Continue

> Steve Kleene: Church was convinced that there were sufficient differences in the way logic was formulated in his system that it would escape the theorem that you couldn't prove its completeness in the system itself. _(Pauses)_ And of course he was right.
>
> _(Everyone laughs)_

1: Why did everyone laugh there?

0: Church was right, but for the wrong reasons. He thought his system would be "good enough" to avoid Gödel's theorem and be complete anyway. Turns out early lambda calculus was complete, it could prove its own consistency, because it was inconsistent and could prove anything.

1: Man, logic is trippy.

> Steve Kleene: For us the first concept of lambda definability was after the fact, after having formulated the notion of lambda definable functions as simply the ones for which you could find formulas in this symbolism. And discovering that everything you thought of that you wanted to prove lambda definable you could!... But it was Church, I have to give the credit to Church, I can't take it myself, he said "Y'know, don't you think maybe we've really got ALL the effectively calculable functions?"

0: He's being generous.

1: To Church?

0: Extremely generous.

1: What do you mean? I thought Church was one of the giants of this whole field.

0: He was. But even Church knew how incredible Kleene was. And Kleene gets ways less credit for all this than he deserves. Dude was clearly the first programmer. I mean sure, Church wrote the first language, Gödel wrote the first compiler, and Turing made what was arguably the first hardware design, but by that same standard, Kleene made:

- Wrote the first standard library.
- Found the first critical vulnerability (λ calculus inconsistency).
- First to have contact with all three of the above and to demonstrate their equivalence.
- First to clean up and popularize the ideas in his (frighteningly technical) _Introduction to Metamathematics_.

1: What do you mean "first standard library"?

0: Well we saw up above how lambda calculus doesn't even come with built-in booleans or integers. And Church didn't even think lambda calculus was powerful enough to express the function $f(x) = x-1$ where x is a positive integer. Kleene's the one who "implemented" all the types and functions that built things from that totally useless level all the way to what eventually became "all computable functions." So Kleene's definitely being humble.

1: Sounds like it. It's crazy I've never heard of this guy before.

0: For real. And from Church's perspective, imagine this grad student of yours who's never even taken a logic class before comes to work with you, learns your system, and then he just keeps knocking off one problem after another until the two of them ended up going from thinking $f(x) = x-1$ is too hard, all the way until Church himself got convinced that _all possible computations_ were representable inside this system.

1: How did Church get convinced?

0: Kleene won't admit this, but it was his "programming" that convinced Church. I mean sure Church designed the lambda calculus, but Kleene figured out how to use it like a frighteningly technical nerd.

1: How do you know?

0: Just read Church's papers. He makes it extremely clear. I swear he cites Kleene in one paper like a hundred times. Check it out.

_(Narrator: 0 clears 0's throat.)_


## Kleeneliness is next to Gödeliness

### Or: Kleene Kleene Kleene
### Or: The First Programmer
### Or: The First Standard Library
### Or: The First Critical Vulnerability
### Or: The First RTFM
### Or: Frighteningly Technical


![[kleene-1.jpg]]


0: Ok so, this is from Church's 1935 paper "An Unsolvable Problem of Elementary Number Theory." This came out about 7 months before Turing's famous paper that showed the same thing. 

1: No way!

![[church-says-kleene-kleene-kleene-00.png]]

0: Turing's paper broke new ground in different ways, but Church got there first.

1: Never heard that before.

0: And if we read this paper, it's pretty clear that "Church" getting there first is like 80-90% Kleene.

1: Kleene's not even a co-author though.

0: Not sure why. Church generally seemed like a generous dude. But just drag your eyes lazily over the pictures below this. This is all from the same paper.

![[church-says-kleene-kleene-kleene-01.png]]


![[church-says-kleene-kleene-kleene-02.png]]


![[church-says-kleene-kleene-kleene-03.png]]


![[church-says-kleene-kleene-kleene-04.png]]


![[church-says-kleene-kleene-kleene-05.png]]


![[church-says-kleene-kleene-kleene-06.png]]


![[church-says-kleene-kleene-kleene-08.png]]


![[church-says-kleene-kleene-kleene-09.png]]


![[church-says-kleene-kleene-kleene-10.png]]


![[church-says-kleene-kleene-kleene-11.png]]


![[church-says-kleene-kleene-kleene-12.png]]


![[church-says-kleene-kleene-kleene-13.png]]


1: Damn that's a lot of Kleene.

0: Church is like "Our integers are different.

![[church-says-kleene-kleene-kleene-14.png]]

0: But this proof is Kleene.

![[church-says-kleene-kleene-kleene-15.png]]


![[church-says-kleene-kleene-kleene-16.png]]

1: Why is he citing him so much?

0: Kleene implemented everything.

1: Definite first programmer vibes.

![[church-says-kleene-kleene-kleene-19.png]]


![[church-says-kleene-kleene-kleene-20.png]]

1: This is an impressive git blame.

0: Seriously. Church is acting more like a faithful `git blame` implementation than a normal human writing an academic paper.

1: The more I learn about these logic folks the more I like them.

0: How so?

1: I dunno. They're nerds. It feels familiar.

![[church-says-kleene-kleene-kleene-21.png]]

1: Church is like "I'm still here guys, I'm gonna say Kleene some more."

![[church-says-kleene-kleene-kleene-22.png]]

1: Good lord man.

![[church-says-kleene-kleene-kleene-23.png]]

1: It keeps going.

![[church-says-kleene-kleene-kleene-24.png]]

1: This is getting ridiculous.

![[church-says-kleene-kleene-kleene-26.png]]

1: I don't even know what he's talking about but this makes me want to read Kleene.

0: We will. That's why I'm showing you this.

1: Why?

0: So you don't get sad when we get to the frighteningly technical book.

1: Uh oh. Is it bad?

0: Nah it's easy. You'll enjoy it.

![[church-says-kleene-kleene-kleene-27.png]]


![[church-says-kleene-kleene-kleene-28.png]]

1: I've got to say, I thought you exaggerating but that was intense.

0: That's from _one_ paper.

1: Damn, Church.

0: Ok but I was unfair to Church earlier. When Kleene said "I have to give the credit to Church, I can't take it myself," he wasn't talking about all the programming, he was talking about Church's Thesis.

1: Which Church's Thesis?

0: The one we didn't talk about yet.

1: Not the PhD one?

0: Not the PhD one.

1: What's the other Church's Thesis?

0: "That's everything."

1: What's everything?

0: Church's Thesis is "Hey Kleene, I think maybe we got everything?"

1: _What's everything?_

0: All the computable functions. Or effectively calculable as they called them back then.

1: That's Church's Thesis? "We're done."

0: That's it.

1: Why "thesis" and not "theorem"?

0: Because it's saying "I think this informal concept equals this formal concept." Can't exactly prove that in the usual mathematical sense. It's pre-mathematics. The hypothesis is that lambda definability captures what we intuitively mean by "computable." Way more powerful than just a theorem.

1: What on earth made him thing "We got ALL computation"?

0: Kleene.

1: Kleene?

0: I mean Kleene's programming. Church was convinced before Kleene was. Then Kleene tried to disprove Church, failed, and got converted.

> Someone: Was Church's thesis just an offhand remark? 
>
> Steve Kleene: Well he spent some months sweating over it. And saying "Don't you think it's so?" And I was a skeptic! When he came out and asserted the thesis I said "He can't be right." So I went home and I thought I would diagonalize myself out. Out of the class of the lambda definable functions and get another effectively calculable function that wasn't lambda definable. Well just in one night I realized you couldn't do that, and from that point on I was a convert.

1: What's a lambda definable function?

0: That's the first programming language.

1: The first programming language?

0: Defined by Church. With standard library implemented by Kleene. And on the basis of which Church's Thesis (this one) was conjectured.

1: Details please!

0: Follow me.

goto: [[lost+found/3/4]]

[^1]: Aka Zermelo Fraenkel set theory with the axiom of Choice, or ZFC.

[^2]: Editor's Note: This appears to be a reference to an earlier section that was not included in the final version of Sudocode.

[^3]: Ibid.

[^4]: Axiom of Choice.

[^5]: Alonzo Church.

[^6]: The other one.

[^7]: See [^4].

[^8]: The first one.